# Copyright (C) 2025 Eclipse Foundation and others. 
# 
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License v. 2.0 which is available at
# http://www.eclipse.org/legal/epl-2.0.
# 
# SPDX-FileType: SOURCE
# SPDX-FileCopyrightText: 2025 Eclipse Foundation
# SPDX-License-Identifier: EPL-2.0


# This action expects to run in the context of a release (tag-initiated) GitHub worflow, using a Ubuntu runner:
# - github.ref_name and github.ref are set to valid/real values, as these are used to determine asset upload target and download URLs
# - Ubuntu runner comes with pre-installed gh and jq binaries (this is currently the case on GitHub)

name: 'tsffer'
description: 'TSF transfer action - uploads a file to a GitHub release and generates a corresponding TSF manifest.'
branding:
  icon: 'link-2'
  color: 'gray-dark'
  
inputs:
  github_token:
    description: 'GitHub token.'
    required: true
    default: ${{ github.token }}
  mode:
    description: 'Operation mode: "file" (default), "reference" or "package".'
    required: false
    default: file  
  tsffer_upload:
    description: 'Boolean (true/false) switch determining whether tsffer assets should be uploaded to release file set (default: false).'
    required: false
  file:
    description: 'Local file to upload (required if mode is "file").'
    required: false
  file_glob:
    description: 'If true the file can be a glob pattern, asset_name is ignored if this is true (only relevant when mode is "file").'
    required: false
  reference_urls:
    description: 'URL(s) reference to evidence, multiple URLs can be provided by using `|` as a separator (required if mode is "reference").'
    required: false
  asset_name:
    description: 'Name of the asset. When not provided and mode is "file", will use the file name; required if mode is "reference".'
    required: false
  asset_description:
    description: 'More detailed description of the asset (Default: `""`).'
    required: false
  asset_type:
    description: 'Type of the asset; free-text field that might be used to e.g. declare an asset to be of type DOCUMENTATION, SOURCE, etc (Default: `""`).'
    required: false
  asset_tsf_ids:
    description: 'List of TSF identifiers that this asset pertains to; can be one or more identifiers separated by commas (Default: `""`).'
    required: false

outputs:
  tsffer_file:
    description: 'Json file containing tsffer metadata.'
    value: ${{ steps.generate_upload_manifest_asset.outputs.tsffer_file }}

runs:
  using: 'composite'
  steps:
    - name: Generate and upload asset and manifest
      id: generate_upload_manifest_asset
      run: |
        set -e
        # This is useful to enable for debugging
        # set -euxo pipefail 

        # Validate required inputs based on mode
        if [ "${{ inputs.mode }}" = "file" ]; then
          if [ -z "${{ inputs.file }}" ]; then
            echo "Input 'file' is required when mode is 'file'."
            exit 1
          fi
        elif [ "${{ inputs.mode }}" = "reference" ]; then
          if [ -z "${{ inputs.reference_urls }}" ]; then
            echo "Input 'reference' is required when mode is 'reference'."
            exit 1
          fi
          if [ -z "${{ inputs.asset_name }}" ]; then
            echo "Input 'asset_name' is required when mode is 'reference'."
            exit 1
          fi
        elif [ "${{ inputs.mode }}" = "package" ]; then
          # No action here
          :
        else
          echo "Invalid mode: ${{ inputs.mode }}. Must be 'file', 'reference' or 'package'."
          exit 1
        fi

        # Placeholder/variable for generated tsffer metadata file
        tsffer_file=""

        # Derive release URL
        release_url="${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ github.ref_name }}"

        # Generate json output with asset manifest data
        generate_file_manifest() {
          local asset_file="$1"

          # Set asset_name to equal file name (sans any path information), if empty
          if [ -z "${{ inputs.asset_name }}" ]; then
            asset_name=$(basename "$asset_file")
          else
            asset_name="${{ inputs.asset_name }}"
          fi

          # Construct artifact download url
          download_url="${{ github.server_url }}/${{ github.repository }}/releases/download/${{ github.ref_name }}/$(basename $asset_file)"

          # Calculate sha256 checksum for asset file
          asset_checksum=$(sha256sum "$asset_file" | awk '{print $1}')

          # Generate JSON manifest for asset, write to output file
          jq -n \
          --arg checksum "$asset_checksum" \
          --arg description "${{ inputs.asset_description }}" \
          --arg download_url "$download_url" \
          --arg name "$asset_name" \
          --argjson tsf_ids "$(echo ${{ inputs.asset_tsf_ids }} | jq -R 'split(",")')" \
          --arg type "${{ inputs.asset_type }}" \
          --arg by_workflow "$GITHUB_WORKFLOW" \
          --arg commit_sha "$GITHUB_SHA" \
          --arg ref "$GITHUB_REF" \
          --arg release_url "$release_url" \
          --arg repository "$GITHUB_REPOSITORY" \
          '{
              "asset-info": {
                  "checksum-sha256": $checksum,
                  "description": $description,
                  "download-url": $download_url,
                  "name": $name,
                  "tsf-ids": $tsf_ids,
                  "type": $type
              },
              "context-info": {
                  "by-workflow": $by_workflow,
                  "commit-sha": $commit_sha,
                  "ref": $ref,
                  "release-url": $release_url,
                  "repository": $repository
              }
          }' 
        }

        # Generate json output with evidence reference/link manifest data
        generate_reference_manifest() {
          local evidence_links="$1"

          # Set asset_name to equal file name (sans any path information), if empty
          if [ -z "${{ inputs.asset_name }}" ]; then
            echo "Input 'asset_name' is empty, but required for mode 'reference'."
            exit 1
          else
            asset_name="${{ inputs.asset_name }}"
          fi


          # Generate JSON manifest for asset, write to output file
          jq -n \
          --arg description "${{ inputs.asset_description }}" \
          --argjson evidence_links "$(echo $evidence_links | jq -R 'split("|")')" \
          --arg name "$asset_name" \
          --argjson tsf_ids "$(echo ${{ inputs.asset_tsf_ids }} | jq -R 'split(",")')" \
          --arg type "${{ inputs.asset_type }}" \
          --arg by_workflow "$GITHUB_WORKFLOW" \
          --arg commit_sha "$GITHUB_SHA" \
          --arg ref "$GITHUB_REF" \
          --arg release_url "$release_url" \
          --arg repository "$GITHUB_REPOSITORY" \
          '{
              "asset-info": {
                  "description": $description,
                  "evidence-links": $evidence_links,
                  "name": $name,
                  "tsf-ids": $tsf_ids,
                  "type": $type
              },
              "context-info": {
                  "by-workflow": $by_workflow,
                  "commit-sha": $commit_sha,
                  "ref": $ref,
                  "release-url": $release_url,
                  "repository": $repository
              }
          }' 
        }

        # Determine asset manifest filename, generate content, upload asset to github.ref_name (github release)
        create_asset_manifest_upload() {
          local input_file="$1"

          # Manifest output filename - release artifact name with appended '.tsffer'
          asset_file=$(basename "$input_file")
          generated_file="$asset_file.tsffer"

          # Generate manifest
          generate_file_manifest "$input_file" >> $generated_file
          tsffer_file=$generated_file

          echo $tsffer_file

          # Always upload asset to release set - tsffer file upload is determined separately (below)
          gh release upload "${{ github.ref_name }}" "$input_file"
        }

        # Generate evidence link/reference content, upload to github.ref_name (github release)
        create_reference_manifest() {
          local evidence_links="$1"

          # Manifest output filename - asset_name with appended '.tsffer'
          generated_file="${{ inputs.asset_name }}.tsffer"

          # Generate manifest
          generate_reference_manifest "$evidence_links" >> $generated_file
          tsffer_file=$generated_file
          echo $tsffer_file
        }

        # Package all tsffer files in a release into an archive, optionally leaving the original files in place
        package_assets() {
          # Download all tsffer files from release context
          mkdir tsffer_assets
          gh run download "${{ github.run_id }}" --pattern '*.tsffer' --dir tsffer_assets

          tsffer_file="tsffer_assets.tar.bz2"
          echo $tsffer_file

          ls -lh tsffer_assets/

          # Package tsffer files into archive
          tar cvfj $tsffer_file -C tsffer_assets $(ls tsffer_assets/*.tsffer | xargs -n1 basename)
        }

        # Main script entry point
        if [ "${{ inputs.mode }}" = "file" ]; then
          # Process files based on file_glob
          if [ "${{ inputs.file_glob }}" = 'true' ]; then
            for file in ${{ inputs.file }}; do
              if [ -f "$file" ]; then
                # Generate and upload asset manifest, and if that works do the actual asset
                create_asset_manifest_upload "$file"
              fi
            done
          else
            # Generate and upload asset manifest, and if that works do the actual asset
            create_asset_manifest_upload "${{ inputs.file }}"
          fi
        elif [ "${{ inputs.mode }}" = "reference" ]; then
          create_reference_manifest "${{ inputs.reference_urls }}"
        elif [ "${{ inputs.mode }}" = "package" ]; then
          package_assets
        fi

        echo $tsffer_file
        echo "tsffer_file=$tsffer_file" >>$GITHUB_OUTPUT

      env:
        GH_TOKEN: ${{ inputs.github_token }}
        OWNER: ${{ github.repository_owner }}
        REPO: ${{ github.event.repository.name }}
      shell: bash

    - name: Upload tsffer file to artifacts store
      uses: actions/upload-artifact@v4
      env:
        GH_TOKEN: ${{ inputs.github_token }}
      with:
        name: ${{ steps.generate_upload_manifest_asset.outputs.tsffer_file }}
        path: ${{ steps.generate_upload_manifest_asset.outputs.tsffer_file }}

    - name: Upload tsffer file to release set
      if: ${{ inputs.tsffer_upload == 'true' }}
      run: gh release upload "${{ github.ref_name }}" "${{ steps.generate_upload_manifest_asset.outputs.tsffer_file }}"
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
